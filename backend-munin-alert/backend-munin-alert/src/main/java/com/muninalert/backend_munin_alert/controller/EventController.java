package com.muninalert.backend_munin_alert.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.muninalert.backend_munin_alert.model.Event;
import com.muninalert.backend_munin_alert.model.User;
import com.muninalert.backend_munin_alert.service.EventService;
import com.muninalert.backend_munin_alert.service.UserService;

/**
 * REST Controller for event operations.
 * 
 * This controller provides endpoints for creating, retrieving, and analyzing
 * safety-related events generated by user devices and actions.
 */
@RestController
@RequestMapping("/api/events")
public class EventController {
    
    private final EventService eventService;
    private final UserService userService;
    
    /**
     * Constructor for dependency injection.
     * 
     * @param eventService The service for event operations
     * @param userService The service for user operations
     */
    @Autowired
    public EventController(EventService eventService, UserService userService) {
        this.eventService = eventService;
        this.userService = userService;
    }
    
    /**
     * Get all events (admin only).
     * 
     * @return ResponseEntity containing a list of all events
     */
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<Event>> getAllEvents() {
        List<Event> events = eventService.findAllEvents();
        return ResponseEntity.ok(events);
    }
    
    /**
     * Get a specific event by ID.
     * 
     * @param id The ID of the event to retrieve
     * @return ResponseEntity containing the event if found
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @securityService.isEventOwner(authentication, #id)")
    public ResponseEntity<Event> getEventById(@PathVariable String id) {
        return eventService.findEventById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    
    /**
     * Get events for the authenticated user.
     * 
     * @return ResponseEntity containing a list of events for the user
     */
    @GetMapping("/my-events")
    public ResponseEntity<List<Event>> getMyEvents() {
        User currentUser = getCurrentUser();
        List<Event> userEvents = eventService.findEventsByUserId(currentUser.getId());
        return ResponseEntity.ok(userEvents);
    }
    
    /**
     * Get events of a specific type for the authenticated user.
     * 
     * @param type The type of events to retrieve
     * @return ResponseEntity containing a list of events of the specified type for the user
     */
    @GetMapping("/my-events/type/{type}")
    public ResponseEntity<List<Event>> getMyEventsByType(@PathVariable Event.EventType type) {
        User currentUser = getCurrentUser();
        List<Event> userEvents = eventService.findEventsByUserIdAndType(currentUser.getId(), type);
        return ResponseEntity.ok(userEvents);
    }
    
    /**
     * Get events for a specific user (admin only).
     * 
     * @param userId The ID of the user
     * @return ResponseEntity containing a list of events for the user
     */
    @GetMapping("/user/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<Event>> getEventsByUserId(@PathVariable String userId) {
        List<Event> userEvents = eventService.findEventsByUserId(userId);
        return ResponseEntity.ok(userEvents);
    }
    
    /**
     * Get events by type (admin only).
     * 
     * @param type The type of events to retrieve
     * @return ResponseEntity containing a list of events of the specified type
     */
    @GetMapping("/type/{type}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<Event>> getEventsByType(@PathVariable Event.EventType type) {
        List<Event> events = eventService.findEventsByType(type);
        return ResponseEntity.ok(events);
    }
    
    /**
     * Get events for a specific device.
     * 
     * @param deviceId The ID of the device
     * @return ResponseEntity containing a list of events from the device
     */
    @GetMapping("/device/{deviceId}")
    @PreAuthorize("hasRole('ADMIN') or @securityService.isDeviceOwner(authentication, #deviceId)")
    public ResponseEntity<List<Event>> getEventsByDeviceId(@PathVariable String deviceId) {
        List<Event> deviceEvents = eventService.findEventsByDeviceId(deviceId);
        return ResponseEntity.ok(deviceEvents);
    }
    
    /**
     * Get events after a specific timestamp.
     * 
     * @param timestamp The timestamp in milliseconds
     * @return ResponseEntity containing a list of events after the specified timestamp
     */
    @GetMapping("/after/{timestamp}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<Event>> getEventsAfterTimestamp(@PathVariable long timestamp) {
        List<Event> events = eventService.findEventsAfterTimestamp(timestamp);
        return ResponseEntity.ok(events);
    }
    
    /**
     * Get the most recent events for the authenticated user.
     * 
     * @param limit The maximum number of events to return (default: 10)
     * @return ResponseEntity containing a list of the most recent events for the user
     */
    @GetMapping("/my-events/recent")
    public ResponseEntity<List<Event>> getMyRecentEvents(@RequestParam(defaultValue = "10") int limit) {
        User currentUser = getCurrentUser();
        List<Event> recentEvents = eventService.findMostRecentEventsByUser(currentUser.getId(), limit);
        return ResponseEntity.ok(recentEvents);
    }
    
    /**
     * Create a new event and process it.
     * 
     * @param event The event to create
     * @return ResponseEntity containing the created and processed event
     */
    @PostMapping
    public ResponseEntity<Event> createEvent(@RequestBody Event event) {
        // Ensure user ID is set to the authenticated user if not provided
        if (event.getUserId() == null || event.getUserId().isEmpty()) {
            User currentUser = getCurrentUser();
            event.setUserId(currentUser.getId());
        }
        
        // Process the event (this will save it and take appropriate actions)
        Event processedEvent = eventService.processNewEvent(event);
        return ResponseEntity.status(HttpStatus.CREATED).body(processedEvent);
    }
    
    /**
     * Delete an event (admin only).
     * 
     * @param id The ID of the event to delete
     * @return ResponseEntity with no content if successful
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> deleteEvent(@PathVariable String id) {
        if (!eventService.findEventById(id).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        
        eventService.deleteEvent(id);
        return ResponseEntity.noContent().build();
    }
    
    /**
     * Delete events older than a specified timestamp (admin only).
     * 
     * @param timestamp The timestamp in milliseconds
     * @return ResponseEntity containing the number of events deleted
     */
    @DeleteMapping("/before/{timestamp}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Integer> deleteEventsOlderThan(@PathVariable long timestamp) {
        int deletedCount = eventService.deleteEventsOlderThan(timestamp);
        return ResponseEntity.ok(deletedCount);
    }
    
    /**
     * Helper method to get the currently authenticated user.
     * 
     * @return The current user
     * @throws RuntimeException if the user is not found
     */
    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        return userService.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
    }
}
